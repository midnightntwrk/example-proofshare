// NOTE: This contract is under construction -- any feedback is welcome!

// ProofShare contract:
// This contract supports privacy-preserving data sharing 
// by allowing users to:
// - Register private data via commitment hashes
// - Authenticate using zero-knowledge proofs
// - Verify the integrity of encrypted payloads off-chain
//
// No private data is stored on-chain. Instead, the contract 
// manages commitments and verifies access via proofs

pragma language_version >= 0.16 && <= 0.17;

import CompactStandardLibrary;

// Ledger state for user commitments and registration status
export ledger user_commitments: Map<Uint<32>, Bytes<32>>; //stores a hash commitment of a user's private data submitted during registration
export ledger registered_users: Map<Uint<32>, Boolean>; // tracks whether a given user_id is registered

constructor() {
}

// Witness functions for off-chain computations
witness generate_commitment(user_id: Uint<32>): Bytes<32>; // returns a cryptographic commitment to some private data bound to the user id
witness verify_auth_proof(user_id: Uint<32>, registered_commitment: Bytes<32>, proof: Bytes<32>): Boolean; // verifies the proof against the registered commitment

//verifies that an off-chain plaintext hashed to `unencrypted_data_hash`
// corresponds to the registered commitment, and that the encrypted payload's hash
// matches what was derived off-chain (binding the plaintext to the encrypted payload).
witness verify_data_integrity_proof(
  user_id: Uint<32>,
  registered_commitment: Bytes<32>,
  unencrypted_data_hash: Bytes<32>,
  encrypted_payload_hash: Bytes<32>,
  proof: Bytes<32>
): Boolean;


// Circuit for User Registration: store commitment after checking it matches the user's private data.
export circuit register_user(user_id: Uint<32>, commitment: Bytes<32>): [] {
  assert(!registered_users.member(disclose(user_id)), "User ID already registered");

  // Bind on-chain commitment to the off-chain private data via witness function.
  const matches_private = disclose(generate_commitment(user_id)) == commitment;
  assert(matches_private, "Commitment does not match user's private data");

  user_commitments.insert(disclose(user_id), disclose(commitment));
  registered_users.insert(disclose(user_id), true);
}

// Circuit for User Authentication: consume proof by verifying it against the stored commitment.
export circuit authenticate_user(user_id: Uint<32>, proof: Bytes<32>): [] {
  assert(registered_users.member(disclose(user_id)), "User not registered");

  // Fetch registered commitment and verify the proof via witness.
  const registered_commitment = user_commitments.lookup(disclose(user_id));
  const ok = disclose(verify_auth_proof(user_id, registered_commitment, proof));
  assert(ok, "Authentication failed: invalid proof");
}

// Circuit for Encrypted Data transfer (with integrity verification): consume both the proof and the payload hash.
export circuit send_encrypted_data(sender_id: Uint<32>, recipient_id: Uint<32>, unencrypted_data_hash: Bytes<32>, encrypted_payload_hash: Bytes<32>, proof: Bytes<32>): [] {
  assert(registered_users.member(disclose(sender_id)), "Sender not registered");
  assert(registered_users.member(disclose(recipient_id)), "Recipient not registered");

  // Verify that the plaintext hash corresponds to the registered commitment AND
  // that the encrypted payload hash is correctly derived/bound to that plaintext.
  const registered_commitment = user_commitments.lookup(disclose(sender_id));
  const integrityVerified = disclose(
    verify_data_integrity_proof(
      sender_id,
      registered_commitment,
      unencrypted_data_hash,
      encrypted_payload_hash,
      proof
    )
  );
  assert(integrityVerified, "Data integrity verification failed: invalid proof");
}
